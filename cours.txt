prios = {
    6 : * / %
    5 : + -
    4 : == != < <= > >=
    3 : &&
    2 : ||
    1 : =
}

OP_BIN = {
    "tok_plus" : {pmin : 5, parg : 6, node : "nd_add"}
    "tok_egal" : {pmin : 1, parg : 1, node : "nd_affect"}
}

Node *E(int prio = 0) {
    N = P(); # première partie de l'expression
    while (OP_BIN[T.Type] != NULL) and  (OP[T.Type].prio >= prio) { # Test si c'est op binaire qui respecte la priorité
        op = T.type;
        next();
        M = E(tbl[op].parg); # suite : aller manger ce qui est de priorité supérieur a l'op courant
        N = node2(op, N, M);
    }
    return N;
}


#gen_node () {


    switch type
        case nd_add:
            gen_node(N->enfants[0]);
            gen_node(N->enfants[1]);
            print("add");
        case nd_mul:
            gen_node(N->enfants[0]);
            gen_node(N->enfants[1]);
            print("mul");

}

I <- E;
  | { I* }
  | debug E;

Node *I(){
    if (check(tok_debug)) {
        N=E();
        accept(tok_;);
        return Node(nd_debug, N);
    } else if (check("tok_{")){
        Node block = Node()
        while (!check("tok_}")) {
            ajoute_enfant(block,I())
        }
        return N;
    }
    else {
        N = E();
        accept(tok_;)
        return Node(nd_drop,N)
    }
}

# Table des symboles

void begin() -> { push(new table)
void end() -> } drop()
sym declare(string name) -> int a; 
sym find(string name) -> a = 5;


find : 
    for (i=top i>= 0 i++){
        if T[i].name == name
        return T[i]
    }
    erreur fatale


I <- .... | int ident;

A <- | ident


affectation : 

arbre :

drop ( affect ( set<index> , calculs ) )

calculs
dup
set <index>
drop


analyse sémantique :
vérifier que le code est sémantiquement correct 
(ici juste avoir a = 6 et pas 6 = a)

générer les indexations des get et set

Void SemNode(Node N) {
    switch N.type:
        default:
            for c in N.children
                SemNode(c)

        case nd_block:
            begin()
            for c in N.children
                SemNode(c)
            end()
        
        case nd_decl
            S = Declare(N.string)
            S.index = Nbvar
            Nbvar++
        
        case nd_ref
            S = Find()
            N.index = S.index
        
        case nd_affect
            if (N.enfants[0].type != nd_ref)
                erreur_fatale
            for ....

        
        
}

gen_code(){
    N = Optim()
    print("resn", nbvar)
    gennode(N)
    print("drop", nbvar)
}

conditions : 

I <- .....
    | if (E) I (else I)?

cond(E, I1, I2?)

e
jump f lxa
I1
jump   lxb
lxa:
I2
lxb:


boucles:

I <- .....
    | while (E) I | break; | continue; | do I while (E); | for (E1;E2;E3) I

while : loop (target cond(Ex I1 break))
do while : loop (target I1 cond(Ex continue break))
for : seq(drop(E1) loop(cond(E2 seq(I1 target drop(E3)) break)))


loop : 


lxa:
I0
I1
...
jump lxa
lxb:

break :
lump lxb

continue : 
lump lxc

target : 
lxc:

int ll

case nd_loop
    int tmp = ll
    ll = nlbl++
    print(".l",ll",a)
    for ... gen_node(enfants)
    print("jump l",ll,a)
    print(".l",ll,"b")
    ll = tmp

case nd_break
    print("jump l", ll,"b)


functions:

F <- ('int'|'void') ident '(' args ')' I


func ( decl... I )

F() {
    accept(tok_int);
    accept(tok_ident);
    accept(tok_();
    if (!check("tok_)")){
        do {
            accept(tok_int);
            accept(tok_ident);
        } while(check(tok_,));
        accept("tok_)");
    }
    I();    
}

return :

I <- ....
    | return E;

return ( E )

calls:

S <- A ('(' args ? ')')

S() {
    N = A();
    if (check("tok_(")) {
        N = Node(nd_call,N)
        boucle sur les args
    }
    return N;
}

gencode de ret: (dans NF)

E
ret 

gencode de func:

.ident
resn nbvar
I
push 0
ret

gencode pour call

prep enfants[0].ident
E1,
E2
.
.
.
En
call nbenfant-1

analyse sem de

AnaSem
    NdAppel
    appel recursif sur les enfants
    if (enfant[0].type != var || Find(enfants[0].ident).type != function)
        arreur fatale
    ndFunc
    Declare(N.ident)
    nbvar = 0
    debutbloc
    boucle sur les enfants
    finblock

code de démarage

.start
prep main
call 0
halt


Pointeurs
I <- int '*'* ident


elif check(tok_int):
    while(check(tok_*)) : pass
    accept(tok_ident)

P <- -P | !P | +P | *P | &P | S

*P -> ind ( P )

*p = 5 -> affect ( ind ( P ) 5)
a = *p -> ..

&P -> adr ( P )

gen_code des pointeurs

ind ( E ) :

E
read

affect ( ... E )

if N.enfants[0].type == nd_ref:
    ...
elif N.enfants[0].type == nd_ind:
    gen_node(N.enfants[1])
    print(dup)
    gen_node(N.enfants[0].enfants[0])
    print(write)

malloc et free: a ajouter dans le code.c direct

void free(int *p) {} ici free faire rien

int *malloc(int n){
    int *p;
    p=*0;
    *0 = *0+n;
    return p;
}

gen_code de &P 

adr ( ref )

prep start
swap
drop 1
push 1
sub
push {N.enfants[0].index}
sub


test :
swap (int *a, int *b){
    int t;
    t = *a;
    *a = *b;
    *b = t;
}

tableaux:

S <- ...
     | A '[' E ']'

ind ( + ( A E ) )

ajout de send et receive

A < ..... | recv

gen_code : recv

I <- send E ;

send ( E )

gen_code : 
E
send

void print(int n) {
    int d; d = n%10;
    int r; r = n/10;
    if (r!0) print(r);
    send 48+d;
}

void println(int v){
    print(v);
    send 10;
}

