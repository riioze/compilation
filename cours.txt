prios = {
    6 : * / %
    5 : + -
    4 : == != < <= > >=
    3 : &&
    2 : ||
    1 : =
}

OP_BIN = {
    "tok_plus" : {pmin : 5, parg : 6, node : "nd_add"}
    "tok_egal" : {pmin : 1, parg : 1, node : "nd_affect"}
}

Node *E(int prio = 0) {
    N = P(); # première partie de l'expression
    while (OP_BIN[T.Type] != NULL) and  (OP[T.Type].prio >= prio) { # Test si c'est op binaire qui respecte la priorité
        op = T.type;
        next();
        M = E(tbl[op].parg); # suite : aller manger ce qui est de priorité supérieur a l'op courant
        N = node2(op, N, M);
    }
    return N;
}


#gen_node () {


    switch type
        case nd_add:
            gen_node(N->enfants[0]);
            gen_node(N->enfants[1]);
            print("add");
        case nd_mul:
            gen_node(N->enfants[0]);
            gen_node(N->enfants[1]);
            print("mul");

}

I <- E;
  | { I* }
  | debug E;

Node *I(){
    if (check(tok_debug)) {
        N=E();
        accept(tok_;);
        return Node(nd_debug, N);
    } else if (check("tok_{")){
        Node block = Node()
        while (!check("tok_}")) {
            ajoute_enfant(block,I())
        }
        return N;
    }
    else {
        N = E();
        accept(tok_;)
        return Node(nd_drop,N)
    }
}

# Table des symboles

void begin() -> { push(new table)
void end() -> } drop()
sym declare(string name) -> int a; 
sym find(string name) -> a = 5;


find : 
    for (i=top i>= 0 i++){
        if T[i].name == name
        return T[i]
    }
    erreur fatale


I <- .... | int ident;

A <- | ident;


affectation : 

arbre :

drop ( affect ( set<index> , calculs ) )

calculs
dup
set <index>
drop


analyse sémantique :
vérifier que le code est sémantiquement correct 
(ici juste avoir a = 6 et pas 6 = a)

générer les indexations des get et set

Void SemNode(Node N) {
    switch N.type:
        default:
            for c in N.children
                SemNode(c)

        case nd_block:
            begin()
            for c in N.children
                SemNode(c)
            end()
        
        case nd_decl
            S = Declare(N.string)
            S.index = Nbvar
            Nbvar++
        
        case nd_ref
            S = Find()
            N.index = S.index
        
        case nd_affect
            if (N.enfants[0].type != nd_ref)
                erreur_fatale
            for .....

        
        
}

gen_code(){
    N = Optim()
    print("resn", nbvar)
    gennode(N)
    print("drop", nbvar)
}