prios = {
    6 : * / %
    5 : + -
    4 : == != < <= > >=
    3 : &&
    2 : ||
    1 : =
}

OP_BIN = {
    "tok_plus" : {pmin : 5, parg : 6, node : "nd_add"}
    "tok_egal" : {pmin : 1, parg : 1, node : "nd_affect"}
}

Node *E(int prio = 0) {
    N = P(); # première partie de l'expression
    while (OP_BIN[T.Type] != NULL) and  (OP[T.Type].prio >= prio) { # Test si c'est op binaire qui respecte la priorité
        op = T.type;
        next();
        M = E(tbl[op].parg); # suite : aller manger ce qui est de priorité supérieur a l'op courant
        N = node2(op, N, M);
    }
    return N;
}


#gen_node () {


    switch type
        case nd_add:
            gen_node(N->enfants[0]);
            gen_node(N->enfants[1]);
            print("add");
        case nd_mul:
            gen_node(N->enfants[0]);
            gen_node(N->enfants[1]);
            print("mul");

}

I <- E;
  | { I* }
  | debug E;

Node *I(){
    if (check(tok_debug)) {
        N=E();
        accept(tok_;);
        return Node(nd_debug, N);
    } else if (check("tok_{")){
        Node block = Node()
        while (!check("tok_}")) {
            ajoute_enfant(block,I())
        }
        return N;
    }
    else {
        N = E();
        accept(tok_;)
        return Node(nd_drop,N)
    }
}

# Table des symboles

void begin() -> { push(new table)
void end() -> } drop()
sym declare(string name) -> int a; 
sym find(string name) -> a = 5;


find : 
    for (i=top i>= 0 i++){
        if T[i].name == name
        return T[i]
    }
    erreur fatale

